package commoneventer

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/go-logr/logr"
	diagnosisv1 "github.com/kubediag/kubediag/api/v1"
	"github.com/kubediag/kubediag/pkg/pagerdutyeventer"
	"github.com/kubediag/kubediag/pkg/util"
	"github.com/prometheus/client_golang/prometheus"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/cache"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
	// CommonEventGeneratedDiagnosisPrefix is the name prefix for diagnoses generated by common event.
	CommonEventGeneratedDiagnosisPrefix = "common-event"
	// CommonEventAnnotation is the annotation used to store the common event that triggers a diagnosis.
	CommonEventAnnotation = util.KubeDiagPrefix + CommonEventGeneratedDiagnosisPrefix
)

var (
	commonEventReceivedCount = prometheus.NewCounter(
		prometheus.CounterOpts{
			Name: "common_event_received_count",
			Help: "Counter of events received by common eventer",
		},
	)
	commonEventDiagnosisGenerationSuccessCount = prometheus.NewCounter(
		prometheus.CounterOpts{
			Name: "common_event_diagnosis_generation_success_count",
			Help: "Counter of successful diagnosis generations by common eventer",
		},
	)
	commonEventDiagnosisGenerationErrorCount = prometheus.NewCounter(
		prometheus.CounterOpts{
			Name: "common_event_diagnosis_generation_error_count",
			Help: "Counter of erroneous diagnosis generations by common eventer",
		},
	)
)

// CommonEventer can handle valid common events.
type CommonEventer interface {
	// Handler handles http requests.
	Handler(http.ResponseWriter, *http.Request)
}

// commonEventer manages common events received by kubediag.
type commonEventer struct {
	// Context carries values across API boundaries.
	context.Context
	// Logger represents the ability to log messages.
	logr.Logger
	// client knows how to perform CRUD operations on Kubernetes objects.
	client client.Client
	// cache knows how to load Kubernetes objects.
	cache cache.Cache
	// commonEventEnabled indicates whether common event is enabled.
	commonEventEnabled bool
}

// NewCommonEventer creates a new CommonEvent.
func NewCommonEventer(
	ctx context.Context,
	logger logr.Logger,
	cli client.Client,
	cache cache.Cache,
	commonEventEnabled bool,
) CommonEventer {
	metrics.Registry.MustRegister(
		commonEventReceivedCount,
		commonEventDiagnosisGenerationSuccessCount,
		commonEventDiagnosisGenerationErrorCount,
	)

	return &commonEventer{
		Context:            ctx,
		Logger:             logger,
		client:             cli,
		cache:              cache,
		commonEventEnabled: commonEventEnabled,
	}
}

// Handler handles http requests for common event
func (ce *commonEventer) Handler(w http.ResponseWriter, r *http.Request) {
	if !ce.commonEventEnabled {
		http.Error(w, "commonEventer is not enabled", http.StatusUnprocessableEntity)
		return
	}

	switch r.Method {
	case "POST":
		commonEventReceivedCount.Inc()

		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			commonEventDiagnosisGenerationErrorCount.Inc()
			ce.Error(err, "unable to read request body")
			http.Error(w, fmt.Sprintf("unable to read request body: %v", err), http.StatusBadRequest)
			return
		}
		defer r.Body.Close()

		var commonEventFormat pagerdutyeventer.PagerDutyPayload
		err = json.Unmarshal(body, &commonEventFormat)
		if err != nil {
			commonEventDiagnosisGenerationErrorCount.Inc()
			ce.Error(err, "failed to unmarshal request body")
			http.Error(w, fmt.Sprintf("failed to unmarshal request body: %v", err), http.StatusInternalServerError)
			return
		}

		triggers, err := ce.listTriggers()
		if err != nil {
			ce.Error(err, "failed to list Triggers")
			return
		}

		diagnosis, err := ce.createDiagnosisFromCommonEvent(triggers, commonEventFormat)
		if err != nil {
			ce.Error(err, "failed to create diagnosis from common eventer")
			return
		}

		if diagnosis != nil {
			ce.Info("creating Diagnosis from common event successfully", "diagnosis", client.ObjectKey{
				Name:      diagnosis.Name,
				Namespace: diagnosis.Namespace,
			})
		}

		commonEventDiagnosisGenerationSuccessCount.Inc()
	default:
		http.Error(w, fmt.Sprintf("method %s is not supported", r.Method), http.StatusMethodNotAllowed)
	}
}

// listTriggers lists Triggers from cache.
func (ce *commonEventer) listTriggers() ([]diagnosisv1.Trigger, error) {
	var triggersList diagnosisv1.TriggerList
	if err := ce.cache.List(ce, &triggersList); err != nil {
		return nil, err
	}

	return triggersList.Items, nil
}

// createDiagnosisFromCommonEvent creates a Diagnosis from common event and triggers.
func (ce *commonEventer) createDiagnosisFromCommonEvent(triggers []diagnosisv1.Trigger, commonEventFormat pagerdutyeventer.PagerDutyPayload) (*diagnosisv1.Diagnosis, error) {
	for _, trigger := range triggers {
		sourceTemplate := trigger.Spec.SourceTemplate
		if sourceTemplate.CommonEventTemplate != nil {
			matched, err := matchCommonEvent(*sourceTemplate.CommonEventTemplate, commonEventFormat)
			if err != nil {
				ce.Error(err, "failed to match trigger and common event")
				continue
			}

			if matched {
				commonEventInfo := fmt.Sprintf("%s.%s.%d", strings.ToLower(commonEventFormat.Group), strings.ToLower(commonEventFormat.Class), pagerdutyeventer.CommonEventToSignature(commonEventFormat))
				ce.Info("creating Diagnosis from common event", "common event", commonEventInfo)
				now := time.Now()
				name := fmt.Sprintf("%s.%s.%d", CommonEventGeneratedDiagnosisPrefix, strings.ToLower(commonEventFormat.Class), now.Unix())
				namespace := util.DefautlNamespace
				annotations := make(map[string]string)
				annotations[CommonEventAnnotation] = name
				diagnosis := diagnosisv1.Diagnosis{
					ObjectMeta: metav1.ObjectMeta{
						Name:        name,
						Namespace:   namespace,
						Annotations: annotations,
					},
					Spec: diagnosisv1.DiagnosisSpec{
						OperationSet:   trigger.Spec.OperationSet,
						TargetSelector: &diagnosisv1.TargetSelector{},
					},
				}
				// Determine node for new diagnosis
				if trigger.Spec.NodeName != "" {
					diagnosis.Spec.TargetSelector.NodeNames = []string{trigger.Spec.NodeName}
				} else {
					ce.Info(trigger.Name, "trigger no node specified")
					continue
				}

				// Skip if pod reference and node name cannot be determined.
				if len(diagnosis.Spec.TargetSelector.PodReferences) == 0 && len(diagnosis.Spec.TargetSelector.NodeNames) == 0 {
					ce.Info("pod reference and node name cannot be determined for commonevent and trigger", "commonevent", commonEventInfo)
					continue
				}

				if err := ce.client.Create(ce, &diagnosis); err != nil {
					if !apierrors.IsAlreadyExists(err) {
						ce.Error(err, "unable to create Diagnosis")
						return &diagnosis, err
					}
				}

				return &diagnosis, nil
			}
		}
	}

	return nil, nil
}

// matchCommonEvent reports whether the diagnosis contains all match of the regular expression pattern
// defined in common event template.
func matchCommonEvent(commonEventTemplate diagnosisv1.CommonEventTemplate, commonEventFormat pagerdutyeventer.PagerDutyPayload) (bool, error) {
	re, err := regexp.Compile(commonEventTemplate.Regexp.Source)
	if err != nil {
		return false, err
	}
	if !re.MatchString(commonEventFormat.Source) {
		return false, nil
	}

	re, err = regexp.Compile(commonEventTemplate.Regexp.Group)
	if err != nil {
		return false, err
	}
	if !re.MatchString(commonEventFormat.Group) {
		return false, nil
	}

	re, err = regexp.Compile(commonEventTemplate.Regexp.Class)
	if err != nil {
		return false, err
	}
	if !re.MatchString(commonEventFormat.Class) {
		return false, nil
	}

	re, err = regexp.Compile(commonEventTemplate.Regexp.Severity)
	if err != nil {
		return false, err
	}
	if !re.MatchString(commonEventFormat.Severity) {
		return false, nil
	}

	re, err = regexp.Compile(commonEventTemplate.Regexp.Component)
	if err != nil {
		return false, err
	}
	if !re.MatchString(commonEventFormat.Component) {
		return false, nil
	}

	return true, nil
}
